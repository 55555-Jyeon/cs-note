# 💻 메모리 관리(feat. 가상 메모리)

## 📖 가상 메모리?

> **가상 메모리(Virtual Memory)**는 RAM을 관리하는 방법 중 하나로, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식을 말한다.

RAM의 부족한 용량을 보완하는데 주로 사용한다..!

윈도우 운영체제는 가동되고 있는 프로세스들의 내용중, 덜 중요한 것들을 하드 디스크에 옮겨놓음. 그리고 프로세스가 동작할 때 필요한 데이터가 없으면 이때 하드디스크에 접근해서 데이터를 찾아온다.
![](https://velog.velcdn.com/images/psik_2/post/5b0fd31d-1bd3-459d-8b3d-af1124d523fd/image.jpeg)
위 사진처럼 가상 메모리로 메모리 용량을 확보할 수 있다😁

가상메모리의 동작 방법을 확인하기전에 페이지와 프레임에 대해 잠깐 알아보면

> **페이지(page)**
> 가상 메모리를 사용하는 최소 크기 단위
>
> **프레임(frame)**
> 물리(실제) 메모리를 사용하는 최소 크기 단위

가상 메모리에 있는 내용을 실제 메모리에 로드할 때, 무작위로 위치 및 크기를 설정하여 로드하면 빈 공간이 발생한다. 이를 최소화하기 위해 페이지와 프레임을 도입하였다❗

운영체제의 스와퍼(swapper)는 실제 메모리에 동작하고 있는 모든 프로세스를 로드하지 않음. 또한 운영체제의 페이저(pager)는 프로세스의 모든 페이지를 실제 메모리에 로드하지 않음.

이때 실제 메모리에 프로그램의 페이지가 부재할 수 있는데 이를 **페이지 폴트**라고 한다.

간단하게 말해서 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에 없는 데이터에 접근했을 때 **페이지 폴트**가 발생한다.

## 📖 요구 페이징

이렇게 페이지 폴트가 발생하면 가상 메모리에서 해당 페이지를 찾아야 하는데 이 과정을 **요구 페이징(Demand Paging)** 이라고 한다.

> 정확히는 필요한 시점에 데이터만 실제 메모리에 적재하는 방법을 **요구 페이징** 이라고 한다. 이와 반대로 프로세스와 관련된 모든 데이터를 실제 메모리에 미리 적재한 뒤 실행하는 **선행 페이징** 방법도 있다.

**즉, 요구 페이징이란 페이지 폴트를 해결하는 과정을 의미하는 것**이다. 요구 페이징을 사용하면 **참조 지역성(Locality of Reference)**으로 인해 페이지 폴트 확률이 줄어든다.

> **💡 참조 지역성(Locality of Reference)**
> 동일한 값 또는 해당 값에 관계된 스토리지 위치가 자주 액세스 되는 특성을 말한다. 참조 지역성의 3가지 기본형에는 시간, 공간, 순차 지역성이 있다.
>
> **1️⃣ 시간 지역성(temporal locality)**
> 최근 사용된 기억 장소들이 집중적으로 엑세스 되는 경향
>
> **2️⃣ 공간 지역성(spatial locality)**
> 특정 클러스트들의 기억 장소들에 대해 참조가 집중적으로 이뤄지는 경향
>
> **3️⃣ 순차 지역성(sequential locality)**
> 데이터가 순차적으로 엑세스 되는 경향

운영 체제는 아래와 같은 **페이지 테이블**로 가상 메모리를 관리한다. 이때 페이지 테이블에는 페이지가 저장되어 있는 주소값이 들어간다. 페이지 테이블에는 **Valid bit**가 있어, 이를 이용해 해당 페이지가 어느 메모리에 있는지 파악할 수 있음.

![](https://velog.velcdn.com/images/psik_2/post/7762fc5f-51e2-4745-8463-676edee4ea84/image.png)

위 사진에서 Page Table Entry의 첫 번째 비트는 **Present bit**로 해당 페이지가 메인 메모리에 존재하는 지를 나타내는 비트이다. 다른말로 **Valid bit**라고도 부른다. 비트값이 1이면 메인 메모리에 존재, 0이면 메인 메모리에 존재하지 않음을 나타낸다

위와 같은 원리를 이용해 운영 체제는 가상 메모리에서 페이지를 쉽게 찾을 수 있다.

운영체제가 페이지 테이블을 이용해 요구 페이징을 하는 과정은 아래와 같다.

![](https://velog.velcdn.com/images/psik_2/post/ddc077da-03a9-4ed6-8afe-095e9000a0b9/image.png)

> 1. CPU는 실제 메모리를 확인하여 페이지가 없으면 trap를 발생시켜 운영체제에 알린다.
>
> 2. trap이 발생했으므로 운영 체제는 cpu의 동작을 잠시 멈춘다.
>
> 3. 운영 체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는 것을 확인하고, 없으면 프로세스를 중단한다.
>
> 4. 페이지 폴트이면, 현재 실제 메모리에 **비어있는 프레임**이 있는지 찾는다.
>
> 5. 비어있는 프레임이 해당 페이지를 로드하고, 페이지 테이블 최신화를 진행한다.
>
> 6. 중단되었던 cpu를 다시 동작시킨다.

위와 같은 과정으로 요구 페이징이 일어난다. 이때 실제 메모리에 **비어있는 프레임** 이 없다면 어떻게 될까?

프로세스를 중간에 멈출 수 없으므로, **희생 프레임**을 선택해서 이를 가상 메모리에 저장한 뒤 필요한 페이지를 실제 메모리에 업로드한다. 그리고 이때 페이지 교체 알고리즘이 사용된다😄

자주 사용되는 페이지 교체 알고리즘은 다음과 같다.

> **FIFO(first in first out)**
> 가장 먼저 물리 메모리에 적재된 페이지를 선택하는 방식
>
> **LRU(least recently used)**
> 가장 오랫동안 사용되지 않았던 페이지를 선택하는 방식
>
> **LFU(least frequently used)**
> 가장 참조 횟수가 적은 페이지를 선택하는 방식
