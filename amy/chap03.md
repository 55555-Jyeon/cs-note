###### date | 2024.03.25 ~ 2024.03.31

###### week | 4th week

# OS

<br />
<br />

## 운영체제와 컴퓨터

### OS

#### OS의 역할

1. CPU 스케줄링과 프로세스 관리
2. 메모리 관리
3. 디스크 파일 관리
4. I/O 디바이스 관리

#### OS의 구조

리눅스 → only CUI (GUI X)

<p align="center">
<img width="70%" src="https://github.com/inside-coding/cs-note/assets/134191817/e4c31623-6800-4806-881b-0e0baf33eabe" />
</p>

<details>
<summary>GUI</summary>
<p>사용자가 전자장치와 상호작용할 수 있도록 하는 사용자 인터페이스의 한 형태</p>
</details>

<details>
<summary>CUI</summary>
<p>그래픽이 아닌 명령어로 처리하는 인터페이스</p>
</details>

<br />
<br />

### 컴퓨터

#### 컴퓨터의 요소

<p align="center">
<img width="80%" src="https://github.com/inside-coding/cs-note/assets/134191817/d4ddcdb7-ff00-4698-aff7-4f7bb033a128" />
</p>

<br />
<br />

## 메모리

### 메모리 계층 ⭐️

구성 요소 → 레지스터, 캐시, 메모리, 저장장치

<p align="center">
<img width="80%" src="https://github.com/inside-coding/cs-note/assets/134191817/d35cf656-3977-406e-96c3-fff624cc172e" />
</p>

계층은 위로 올라갈수록 가격은 비싸지고, 용량은 작아지고, 속도는 빨라지는데 이는 **경제성과 캐시**와 관련이 있다.

<br />
<br />

### 메모리 관리

##### 01. virtual memory

**가상 메모리**는 메모리 관리 기법의 하나로 컴퓨터가 실제 이용 가능한 메모리 자원을 추상화해 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것

- 가상 메모리는 가상 주소와 실제 주소가 매핑
- 프로세스의 주소 정보가 들어있는 '페이지 테이블'로 관리
- 속도 향상을 위해 TLB를 사용

가상 메모리에는 존재하지만 실제 메모리(RAM)에 현재 없는 데이터/코드에 접근할 경우 페이지 폴트(page fault) 발생 <br />

페이지 폴트 발생 시 스와핑으로 처리

<details>
<summary>swapping (스와핑)</summary>
<p>메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것</p>
</details>

<br />

##### 02. thrashing

스레싱은 메모리의 페이지 폴트율을 높이는 것

- 컴퓨터의 심각한 성능 저하를 초래

[ 스레싱 과정 ]

1️⃣ 메모리에 과도한 프로세스가 동시에 올라감 <br />
2️⃣ 스와핑이 덩달아 많이 발생 <br />
3️⃣ 페이지 폴트 발생 시 CPU 이용률 저하 <br />
4️⃣ OS는 "CPU가 한가한가?" 란 생각이 듦 <br />
5️⃣ 가용성을 더욱 높이기 위해 더 많은 프로세스를 메모리로 올림 <br />

<br />

[ 스레싱 해결 방법 ]

- 메모리 늘리기
- HDD를 SSD로 변경
- OS에서 작업 세트나 PFF 사용하기

<br />
<br />

### 메모리 할당

메모리에 프로그램을 할당할 때 시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당

<br />

### 페이지 교체 알고리즘

메모리는 한정되어 있기 때문에 스와핑이 많이 발생 <br />
스와핑은 페이지 교체 알고리즘을 기반으로 발생 <br />

<br />
<br />

## 프로세스와 스레드

<details>
<summary>프로세스</summary>
<ul>
    <li>컴퓨터에서 실행되고 있는 프로그램</li>
    <li>CPU 스케줄링의 대상이 되는 작업</li>
</ul>
</details>

<details>
<summary>스레드</summary>
<p>프로세스 내 작업의 흐름</p>
</details>

### 프로세스와 컴파일 과정

프로세스는 프로그램이 메모리에 올라가 인스턴스화된 것 <br />

    example

    프로그램 → 구글 크롬 프로그램 같은 실행 파일
    더블클릭 → 구글 크롬 프로세스로 변환

<p align="center">
<img width="80%" src="https://github.com/inside-coding/cs-note/assets/134191817/36e4233b-32ad-4548-b630-f3fe373898cc" />
</p>

<br />

### 프로세스의 상태

<p align="center">
<img width="80%" src="https://github.com/inside-coding/cs-note/assets/134191817/69bbe86c-0fd0-483f-abeb-8fb627c04c01" />
</p>

##### 1️⃣ 생성 상태

- `fork()` / `exec()` 함수를 통해 생성
- PCB 할당

##### 2️⃣ 대기 상태

- 메모리 공간 충분 시 메모리를 할당 받지만 메모리 공간 불충분 시 대기 상태
- CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태

##### 3️⃣ 대기 중단 상태

- 메모리 부족으로 일시 중단된 상태

##### 4️⃣ 실행 상태

- CPU 소유권과 메모리를 할당받고 instruction을 수행 중인 상태
- CPU burst가 일어났다고 표현

##### 5️⃣ 중단 상태

- 어떤 이벤트 발생 이후 기다리며 프로세스가 차단된 상태
- I/O 디바스에 의한 방해로 발생하기도 함

##### 6️⃣ 일시 중단 상태

- 대기 중단과 유사
- 중단된 상태에서 프로세스가 실행하려 했으나 메모리 부족으로 일시 중단된 상태

##### 7️⃣ 종료 상태

- 메모리와 CPU 소유권을 모두 놓고 가는 상태
- 자발적 종료와 비자발적 종료(강제 종료, abort)

<br />

### 프로세스의 메모리 구조

<p align="center">
<img width="80%" src="https://github.com/inside-coding/cs-note/assets/134191817/440d4dd2-b959-4685-9f13-328e65dcb27e" />
</p>

<br />

### PCB

###### Process Control Block

PCB는 운영체제에서 프로세스에 대한 메타데이터를 저장한 '데이터'. <br />
프로세스 제어 블록이라고도 함. <br />
프로세스가 생성되면 운영체제는 해당 PCB 생성

- 프로그램 실행 시 프로세스 생성
- 프로세스 주소 값들에 스택, 힙 등의 구조를 기반으로 메모리가 할당됨
- 프로세스의 메타데이터가 PCB에 저장되어 관리됨

프로세스의 중요한 정보를 담고 있어 일반 사용자의 접근을 제한하기 위해 커널 스택의 가장 앞부분에서 관리.

<br />

#### 컨텍스트 스위칭

###### context switching

PCB를 기반으로 프로세스의 상태를 저장하고 로드시키는 과정 <br />
한 프로세스에서 할당된 시간이 끝나거나 방해에 의해 발생 <br />

컴퓨터에서 실행되고 있는 프로세스는 **단 한 개** <br />
많은 프로세스가 동시에 구동되는 것처럼 보이는 이유는 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 실행되기 때문.

<p align="center">
<img width="80%" src="https://github.com/inside-coding/cs-note/assets/134191817/b5665d59-ee85-42c2-a2d6-55df35ba59c5" />
</p>

<details>
<summary>비용: 캐시미스</summary>
<p>
    컨텍스트 스위칭이 일어날 때 프로세스가 갖고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시 클리어 과정을 겪게 되고 이 때문에 캐시미스가 발생.
</p>
</details>

<br />

### 멀티프로세싱

멀티 프로세싱은 멀티프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것.

- 하나 이상의 일을 병렬적으로 처리 가능
- 프로세스 중 일부에 문제가 발생되더라도 다른 프로세스를 이용해 처리 가능
- 높은 신뢰성

#### 웹 브라우저

웹 브라우저는 멀티프로세스 구조를 갖고 있다.

<p align="center">
<img width="80%" src="https://github.com/inside-coding/cs-note/assets/134191817/37de203a-cd7d-4bd5-b8bf-78177220fe4a" />
</p>

#### IPC

###### Inter Process Communication

IPC는 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 매커니즘

- 멀티프로세스는 IPC가 가능
- client와 server의 관계도 이에 해당
- 메모리가 완전히 공유되는 스레드보다는 속도가 떨어짐
- 종류 : 공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메시지 큐

<br />

### 스레드와 멀티스레딩

#### 스레드

프로세스의 실행 가능한 가장 작은 단위 <br />

<p align="center">
<img width="80%" src="https://github.com/inside-coding/cs-note/assets/134191817/b4234d5f-cb38-48a9-928b-59ef1abaa21b" />
</p>

- 프로세스는 여러 스레드를 가질 수 있음
- 프로세스 : 코드, 데이터, 스택, 힙을 각각 생성
- 스레드 : 코드, 데이터, 힙은 스레드끼리 공유 / 그 외 각각 생성

<br />

#### 멀티스레딩

프로세스 내 작업을 여러 개의 스레드, 멀티스레드로 처리하는 기법 <br />

- 스레드끼리 자원을 공유하므로 높은 효율성
- 동시성에 큰 장점
- 한 스레드에 문제 발생 시 다른 스레드에도 영향을 미치는 것이 단점
- 예시) 웹 브라우저의 렌더러 프로세스

<br />

### 공유 자원과 임계 영역

#### 공유 자원 (shared resource)

시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수 등을 의미.

두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태(race condition)이라고 함.

<br />

#### 임계 영역 (critical section)

둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역.

- 해결 방법 : 뮤텍스, 세마포어, 모니터
- 해결 방법 세 가지 모두 상호 배제, 한정 대기, 융통성이란 조건 충족
- 이 방법들의 토대가 되는 매커니즘은 **잠금**

<br />

### 교착 상태

###### deadlock

두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태.

<p align="center">
<img width="80%" src="https://github.com/inside-coding/cs-note/assets/134191817/a13656e1-2d81-4910-9c70-8ed54e6cb8b8" />
</p>

##### 원인

- 상호 배제
  - 한 프로세스가 자원을 독점
  - 다른 프로세스들의 접근이 불가능
- 점유 대기
  - 특정 프로세스가 점유한 자원을 다른 프로세스가 요청
- 비선점
  - 다른 프로세스의 자원을 강제적으로 가져올 수 없음
- 환형 대기
  - 서로가 서로의 자원을 요구하는 상황
  - <img width="80%" src="https://github.com/inside-coding/cs-note/assets/134191817/745c94d0-07c9-4b58-93c7-83beef23d650" />

##### 해결 방법

1. 자원 할당 시 애초에 조건이 성립되지 않도록 설계
2. '은행원 알고리즘' 사용
   - 교착 상태 가능성이 없을 때에만 자원 할당
   - 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악
3. 교착 상태 발생 시 사이클이 있는지 확인 후 이에 관련된 프로세스를 한 개씩 삭제
4. 교착 상태는 드물게 발생하므로 발생 시 사용자가 작업을 종료

<br />
<br />

## CPU 스케줄링 알고리즘

CPU 스케줄러는 CPU 스케줄링 알고리즘에 따라 프로세스에서 해야할 일을 스레드 단위로 CPU에 할당

<p align="center">
<img width="80%" src="https://github.com/inside-coding/cs-note/assets/134191817/50008350-7653-42a9-a6f7-a607578446d2" />
</p>

프로그램이 실행될 땐 CPU 스케줄링 알고리즘이 어떤 프로그램에 CPU 소유권을 줄지 결정

##### CPU 스케줄링 알고리즘의 목표

1. CPU 이용률은 높게
2. 주어진 시간에 많은 일을 하게
3. 준비 큐(ready queue)에 있는 프로세스는 적게
4. 응답 시간은 짧게 설정

<br />

#### 비선점형 방식 (non-preemptive)

- 프로세스가 스스로 CPU 소유권을 포기하는 방식
- 강제로 프로세스 중단 X
- 컨텍스트 스위칭으로 인한 부하가 적음

##### FCFS

- First Come, First Served (선입선출) 알고리즘
- 길게 수행되는 프로세스 때문에 convoy effect(준비 큐에서 오래 기다리는 현상)이 발생

##### SJF

- Shortest Job First
- 실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘
- starvation(긴 시간을 가진 프로세스가 실행되지 않는 현상)이 일어남
- 평균 대기 시간이 가장 짧음

##### 우선순위

- SJF의 단점을 보완
- 우선순위를 높이는 방법을 사용함으로써 위의 단점을 보완한 알고리즘

<br />

#### 선점형 방식 (preemptive)

- 현대 운영체제가 사용하는 방식
- 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시키고 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식

##### 라운드 로빈

- RR, Round Robin
- 현대 컴퓨터가 쓰는 선점형 알고리즘 스케줄링 방법
- 각 프로세스는 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘
- 로드밸런서에서 트래픽 분산 알고리즘으로도 쓰임

##### SRF

- Shortest Remaining Time First
- SRF는 SJF와 달리 중간에 더 짧은 작업이 들어오면 수행하던 ㅡㅍ로ㅔㅅ스를 중지하고 해당 프로세스를 수행하는 알고리즘

##### 다단계 큐

- 우선순위에 따른 준비 큐를 여러 개 사용
- 큐마다 라운드 로빈이나 FCFS 등 다른 스케줄링 알고리즘을 적용
- 큐 간의 프로세스 이동이 안 되므로 스케줄링 부담이 적음
- 유연성이 떨어짐
- <img width="80%" src="https://github.com/inside-coding/cs-note/assets/134191817/4bbb6555-aeae-42ae-86c2-9b86a754d4ba" />

<br />
<br />
